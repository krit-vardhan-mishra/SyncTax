"""
Audio downloader using yt-dlp
Downloads audio from YouTube and other platforms with album art embedding
"""
import json
import os
from typing import Dict, Any


def map_format_id_to_selector(format_id: str) -> str:
    """
    Maps format IDs to format selectors to bypass YouTube restrictions.
    YouTube blocks specific format ID downloads but allows format selectors.
    
    Format ID examples:
    - 251: Opus ~160kbps (webm)
    - 250: Opus ~70kbps (webm)
    - 249: Opus ~50kbps (webm)
    - 140: AAC 128kbps (m4a)
    - 139: AAC 48kbps (m4a)
    
    Args:
        format_id: The specific format ID selected by the user
        
    Returns:
        Format selector string that YouTube accepts
    """
    # Opus formats (webm container)
    if format_id in ['251', '250', '249', '600']:
        return 'bestaudio[ext=webm]/bestaudio'
    
    # AAC formats (m4a container)
    elif format_id in ['140', '139', '141']:
        return 'bestaudio[ext=m4a]/bestaudio'
    
    # Generic audio formats
    elif format_id in ['ba', 'bestaudio']:
        return 'bestaudio'
    
    # If specific format ID, try it but fallback to bestaudio
    else:
        return f'{format_id}/bestaudio'



def download_audio(url: str, output_dir: str, prefer_mp3: bool = False, format_id: str = None, po_token: str = None) -> str:
    """
    Download audio from a URL using yt-dlp with embedded album art

    Args:
        url: Video/audio URL to download
        output_dir: Directory to save the downloaded file
        prefer_mp3: If True and FFmpeg is available, convert to MP3. Otherwise use M4A with embedded art.
        format_id: Specific format ID to download. If None, uses best audio format.
        po_token: Optional PO Token for YouTube authentication (bypasses 403 errors)

    Returns:
        JSON string with download result
    """
    try:
        import sys
        print(f"üéµ Python: Starting download_audio", file=sys.stderr)
        print(f"üéµ Python: URL: {url}", file=sys.stderr)
        print(f"üéµ Python: Output directory: {output_dir}", file=sys.stderr)
        if po_token:
            print(f"üéµ Python: PO Token provided (length: {len(po_token)})", file=sys.stderr)

        import yt_dlp

        # Ensure output directory exists
        os.makedirs(output_dir, exist_ok=True)
        print(f"üéµ Python: Output directory created/verified", file=sys.stderr)

        # Check if FFmpeg is available
        ffmpeg_available = False
        ffmpeg_path = None

        print(f"üéµ Python: Checking for FFmpeg...", file=sys.stderr)

        # Try system PATH first
        try:
            import subprocess
            result = subprocess.run(['ffmpeg', '-version'], capture_output=True, timeout=5)
            ffmpeg_available = result.returncode == 0
            if ffmpeg_available:
                ffmpeg_path = 'ffmpeg'
                print(f"üéµ Python: FFmpeg found in PATH", file=sys.stderr)
        except Exception as e:
            print(f"üéµ Python: FFmpeg not in PATH: {e}", file=sys.stderr)

        # If not in PATH, try local tools directory (Android uses 'ffmpeg' not 'ffmpeg.exe')
        if not ffmpeg_available:
            # Get the project root directory (5 levels up from this file)
            current_file = os.path.abspath(__file__)
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(current_file)))))
            # Try both with and without .exe extension for cross-platform compatibility
            for ffmpeg_name in ['ffmpeg', 'ffmpeg.exe']:
                local_ffmpeg = os.path.join(project_root, 'tools', 'ffmpeg-8.0.1-essentials_build', 'bin', ffmpeg_name)
                print(f"üéµ Python: Checking local FFmpeg at: {local_ffmpeg}", file=sys.stderr)
                if os.path.exists(local_ffmpeg):
                    try:
                        result = subprocess.run([local_ffmpeg, '-version'], capture_output=True, timeout=5)
                        if result.returncode == 0:
                            ffmpeg_available = True
                            ffmpeg_path = local_ffmpeg
                            print(f"üéµ Python: FFmpeg found locally at {local_ffmpeg}", file=sys.stderr)
                            break
                    except Exception as e:
                        print(f"üéµ Python: Local FFmpeg check failed: {e}", file=sys.stderr)

        print(f"üéµ Python: FFmpeg available: {ffmpeg_available}", file=sys.stderr)

        # List of YouTube clients to try in order (from most compatible to least)
        clients_to_try = ['android', 'web', 'tv', 'ios', 'mweb']

        last_error = None

        for client in clients_to_try:
            try:
                print(f"üéµ Python: Trying YouTube client: {client}", file=sys.stderr)

                # Configure yt-dlp options for this client
                ydl_opts = {
                    'quiet': False,
                    'no_warnings': False,
                    'nocheckcertificate': True,
                    'prefer_free_formats': True,
                    'postprocessors': [],
                    'outtmpl': os.path.join(output_dir, '%(title)s.%(ext)s'),
                    'extractor_args': {
                        'youtube': {
                            'skip': ['hls', 'dash'],
                            'player_client': [client],
                        }
                    },
                }

                # Add PO Token if provided
                if po_token:
                    # PO Token format: "web+TOKEN" or "android+TOKEN"
                    # Extract client type from token if present
                    if '+' in po_token:
                        token_client, token_value = po_token.split('+', 1)
                        ydl_opts['extractor_args']['youtube']['po_token'] = [f'{token_client}+{token_value}']
                        print(f"üéµ Python: Using PO Token for {token_client} client", file=sys.stderr)
                    else:
                        # If no client specified, use for current client
                        ydl_opts['extractor_args']['youtube']['po_token'] = [f'{client}+{po_token}']
                        print(f"üéµ Python: Using PO Token for {client} client (no client prefix found)", file=sys.stderr)

                # Set format based on whether format_id is specified
                if format_id:
                    # Map format ID to format selector to bypass YouTube restrictions
                    format_selector = map_format_id_to_selector(format_id)
                    ydl_opts['format'] = format_selector
                    print(f"üéµ Python: Using specified format: {format_id}", file=sys.stderr)
                    print(f"üéµ Python: Mapped to format selector: {format_selector}", file=sys.stderr)
                else:
                    # Select best audio format - prefer audio-only, fallback to smallest video+audio for audio extraction
                    # YouTube audio formats: 140 (m4a 128k), 139 (m4a 48k), 141 (m4a 256k), 251 (webm opus), 250 (webm opus), 249 (webm opus)
                    # If audio-only not available, use smallest video format (18) for audio extraction
                    ydl_opts['format'] = 'bestaudio/best[height<=360]'
                    print(f"üéµ Python: Using audio format selection (prefer audio-only, fallback to video with audio)", file=sys.stderr)

                # Add post-processing to extract audio and embed metadata if FFmpeg is available
                if ffmpeg_available and ffmpeg_path:
                    ydl_opts['ffmpeg_location'] = ffmpeg_path

                    # Determine preferred codec based on format_id or default to opus
                    preferred_codec = 'opus'  # Default: best quality/compression
                    if format_id:
                        # Try to infer codec from format_id
                        if '140' in format_id or '141' in format_id or '139' in format_id:
                            preferred_codec = 'm4a'
                        elif '251' in format_id or '250' in format_id or '249' in format_id:
                            preferred_codec = 'opus'

                    # YTDLNIS-style post-processors for high-quality audio with metadata
                    ydl_opts['postprocessors'] = [
                        {
                            'key': 'FFmpegExtractAudio',
                            'preferredcodec': preferred_codec,
                            'preferredquality': '0',  # Best quality
                        },
                        {
                            'key': 'FFmpegMetadata',
                            'add_metadata': True,
                        },
                        {
                            'key': 'EmbedThumbnail',
                            'already_have_thumbnail': False,
                        },
                    ]

                    # Write metadata to file
                    ydl_opts['writethumbnail'] = True
                    ydl_opts['writeinfojson'] = False  # Don't create .info.json files

                    print(f"üéµ Python: FFmpeg available - will extract {preferred_codec} with metadata", file=sys.stderr)
                else:
                    # Without FFmpeg, we still need to extract audio from video formats
                    # yt-dlp can do basic audio extraction without FFmpeg for some formats
                    print(f"üéµ Python: FFmpeg not available - will download and extract audio using yt-dlp", file=sys.stderr)

                print(f"üéµ Python: Starting yt-dlp download with client {client}...", file=sys.stderr)

                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = ydl.extract_info(url, download=True)

                    print(f"üéµ Python: Download completed with client {client}", file=sys.stderr)
                    print(f"üéµ Python: Title: {info.get('title', 'Unknown')}", file=sys.stderr)

                    # Get the final filename (already includes output directory from outtmpl)
                    base_filename = ydl.prepare_filename(info)

                    # After post-processing, the extension might change
                    # Check for the actual file with the post-processed extension
                    possible_extensions = ['opus', 'm4a', 'mp3', 'webm', info.get('ext', 'mp4')]
                    filename = None

                    base_without_ext = os.path.splitext(base_filename)[0]

                    for ext in possible_extensions:
                        test_path = base_without_ext + '.' + ext
                        if os.path.exists(test_path):
                            filename = test_path
                            print(f"üéµ Python: Found file with extension: {ext}", file=sys.stderr)
                            break

                    # Fallback: try without ID suffix (yt-dlp may remove it)
                    if not filename and '[' in base_without_ext and ']' in base_without_ext:
                        title_part = base_without_ext.split(' [')[0]
                        for ext in possible_extensions:
                            test_path = title_part + '.' + ext
                            if os.path.exists(test_path):
                                filename = test_path
                                print(f"üéµ Python: Found file without ID suffix: {ext}", file=sys.stderr)
                                break

                    if not filename:
                        # Last resort: use the original filename
                        filename = base_filename

                    print(f"üéµ Python: Final file path: {filename}", file=sys.stderr)
                    print(f"üéµ Python: File exists: {os.path.exists(filename)}", file=sys.stderr)
                    if os.path.exists(filename):
                        file_size_mb = os.path.getsize(filename) / (1024 * 1024)
                        print(f"üéµ Python: File size: {file_size_mb:.2f}MB", file=sys.stderr)

                    result = {
                        "success": True,
                        "message": f"Download completed successfully using {client} client",
                        "file_path": filename,
                        "format": info.get('ext', 'unknown'),
                        "ffmpeg_available": ffmpeg_available,
                        "client_used": client,
                    }

                    print(f"üéµ Python: ‚úÖ Success with client {client}!", file=sys.stderr)
                    return json.dumps(result)

            except Exception as e:
                error_msg = str(e)
                print(f"üéµ Python: ‚ùå Client {client} failed: {error_msg}", file=sys.stderr)
                last_error = error_msg
                continue

        # If we get here, all clients failed
        print(f"üéµ Python: ‚ùå All clients failed, last error: {last_error}", file=sys.stderr)

        # Check if error is related to missing PO Token
        error_message = f"Download failed with all clients. Last error: {last_error}"
        if not po_token and ('403' in last_error or 'Forbidden' in last_error or 'Signature extraction failed' in last_error):
            error_message = "‚ö†Ô∏è YouTube PO Token Required!\n\nYouTube now requires a PO Token for downloading. Please:\n1. Click the üîë button in the format dialog\n2. Follow the guide to get a token\n3. Enter the token and try again\n\nLast error: " + last_error
        elif po_token and ('403' in last_error or 'Forbidden' in last_error):
            error_message = "‚ö†Ô∏è PO Token expired or invalid!\n\nYour PO Token may have expired (tokens last ~6 hours). Please:\n1. Get a new token from the guide\n2. Update it in the format dialog\n3. Try downloading again\n\nLast error: " + last_error

        return json.dumps({
            "success": False,
            "message": error_message,
            "file_path": "",
        })

    except ImportError as e:
        import sys
        print(f"üéµ Python: ‚ùå ImportError: {str(e)}", file=sys.stderr)
        return json.dumps({
            "success": False,
            "message": f"yt-dlp not installed: {str(e)}",
            "file_path": "",
        })
    except Exception as e:
        import sys
        import traceback
        print(f"üéµ Python: ‚ùå Exception: {str(e)}", file=sys.stderr)
        print(f"üéµ Python: Stack trace:", file=sys.stderr)
        traceback.print_exc(file=sys.stderr)
        return json.dumps({
            "success": False,
            "message": f"Download failed: {str(e)}",
            "file_path": "",
        })


def get_video_info(url: str, po_token: str = None) -> str:
    """
    Get video information including all available formats from all clients
    
    Args:
        url: Video/audio URL
        po_token: Optional PO Token for YouTube authentication
        
    Returns:
        JSON string with video information and formats
    """
    try:
        import yt_dlp
        import sys
        
        print(f"üéµ Python: Getting video info for URL: {url}", file=sys.stderr)
        if po_token:
            print(f"üéµ Python: PO Token provided for get_video_info", file=sys.stderr)
        
        # List of YouTube clients to try
        clients_to_try = ['android', 'web', 'tv', 'ios', 'mweb']
        
        all_formats = []
        video_info = {}
        successful_client = None
        
        for client in clients_to_try:
            try:
                print(f"üéµ Python: Trying client: {client}", file=sys.stderr)
                
                ydl_opts = {
                    'quiet': True,
                    'no_warnings': True,
                    'extract_flat': False,
                    'extractor_args': {
                        'youtube': {
                            'skip': ['hls', 'dash'],
                            'player_client': [client],
                        }
                    },
                }
                
                # Add PO Token if provided
                if po_token:
                    if '+' in po_token:
                        token_client, token_value = po_token.split('+', 1)
                        ydl_opts['extractor_args']['youtube']['po_token'] = [f'{token_client}+{token_value}']
                        print(f"üéµ Python: Using PO Token for {token_client} client in get_video_info", file=sys.stderr)
                    else:
                        ydl_opts['extractor_args']['youtube']['po_token'] = [f'{client}+{po_token}']
                        print(f"üéµ Python: Using PO Token for {client} client in get_video_info", file=sys.stderr)
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = ydl.extract_info(url, download=False)
                    
                    if info:
                        successful_client = client
                        video_info = {
                            "success": True,
                            "title": info.get('title', 'Unknown'),
                            "artist": info.get('artist') or info.get('uploader', 'Unknown'),
                            "duration": info.get('duration', 0),
                            "thumbnail_url": info.get('thumbnail', ''),
                            "description": info.get('description', ''),
                            "client_used": client,
                        }
                    
                    # Extract format information and add client info
                    if 'formats' in info:
                        for fmt in info['formats']:
                            # Only include formats that have audio
                            acodec = fmt.get('acodec', 'none')
                            vcodec = fmt.get('vcodec', 'none')
                            format_id = fmt.get('format_id', '')
                            
                            # Skip storyboards and image-only formats
                            if 'sb' in format_id or fmt.get('ext') == 'mhtml':
                                continue
                            
                            # Include formats that have audio:
                            # 1. Pure audio formats (acodec != none, vcodec == none)
                            # 2. Combined video+audio formats that can be converted (like format 18)
                            # 3. Known audio format IDs: 140, 139, 141, 249, 250, 251, 171, 172
                            has_audio = acodec != 'none' and acodec != ''
                            
                            if has_audio:
                                # Determine if it's audio-only or combined
                                is_audio_only = (
                                    vcodec == 'none' or 
                                    fmt.get('resolution') == 'audio only' or
                                    format_id in ['140', '139', '141', '249', '250', '251', '171', '172']
                                )
                                
                                # Extract comprehensive format information
                                format_info = {
                                    'format_id': format_id,
                                    'container': fmt.get('ext', ''),  # Map 'ext' to 'container' for Format.kt
                                    'ext': fmt.get('ext', ''),
                                    'resolution': fmt.get('resolution', 'audio only' if is_audio_only else 'combined'),
                                    'fps': str(fmt.get('fps', '')) if fmt.get('fps') else None,
                                    'vcodec': vcodec,
                                    'acodec': acodec,
                                    'encoding': fmt.get('encoding', ''),
                                    'filesize': fmt.get('filesize', 0) or fmt.get('filesize_approx', 0) or 0,
                                    'format_note': fmt.get('format_note', '') or fmt.get('quality', '') or ('audio only' if is_audio_only else 'combined'),
                                    'asr': str(fmt.get('asr', '')) if fmt.get('asr') else None,  # Audio sample rate
                                    'url': fmt.get('url', ''),
                                    'lang': fmt.get('language', '') or fmt.get('audio_lang', ''),  # Audio language
                                    'tbr': str(fmt.get('tbr', '')) if fmt.get('tbr') else str(fmt.get('abr', '')) if fmt.get('abr') else None,  # Total/audio bitrate
                                    'abr': fmt.get('abr'),  # Keep for backward compatibility
                                    'client': client,
                                    'audio_only': is_audio_only,
                                }
                                all_formats.append(format_info)
                    
                    break  # Success, exit loop
                    
            except Exception as e:
                print(f"üéµ Python: Client {client} failed: {str(e)}", file=sys.stderr)
                # Continue to next client
                continue
        
        if successful_client:
            video_info["formats"] = all_formats
            print(f"üéµ Python: ‚úÖ Got video info with {len(all_formats)} formats using {successful_client} client", file=sys.stderr)
            return json.dumps(video_info, default=str)
        else:
            print(f"üéµ Python: ‚ùå Failed to get video info with all clients", file=sys.stderr)
            return json.dumps({
                "success": False,
                "message": f"Failed to get video info with all clients",
            })
            
    except Exception as e:
        import sys
        print(f"üéµ Python: ‚ùå Exception in get_video_info: {str(e)}", file=sys.stderr)
        return json.dumps({
            "success": False,
            "message": f"Failed to get video info: {str(e)}",
        })
